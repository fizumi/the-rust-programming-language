<!-- https://github.com/DavidAnson/markdownlint/tree/v0.23.1#configuration -->
<!-- markdownlint-disable MD024 -->

# [The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja)

The Book の復習用メモ

## コマンドライン

### rustc

- バージョン確認
  - `rustc --version`
- コンパイル
  - `rustc main.rs`
    - コンパイラ で `main.rs` をコンパイル

### cargo

- バージョン確認
  - `cargo --version`
- プロジェクト作成
  - `cargo new hello_cargo` （--bin と同じ）
  - `cargo new hello_cargo --bin`
  - `cargo new hello_cargo --lib`
  - `cargo new --lib hello_cargo`
- ビルド
  - `cargo build`
- 実行
  - `./target/debug/hello_cargo`
    - ※ Cargo はビルドの結果を target/debug ディレクトリに格納する。
      - 「リリースビルド」（cargo build --release / 実行は速いがコンパイル速度は遅い）の場合を除く
- ビルド & 実行
  - `cargo run`
    - 複数のワークスペースが存在する場合、`cargo run -p [pkg_name]` で `[pkg_name]` パッケージを実行
- コンパイルが通る確認のみ
  - `cargo check`
- クレートを更新して新バージョンを取得する
  - `cargo update`
    - Cargo.lock ファイルに書かれているバージョンが変更される
- テスト
  - `cargo test`
    - `-p` フラグ：ワークスペースを使っている場合、テストしたいクレートの名前を指定することで最上位ディレクトリからある特定のクレートのテストを実行することができる
- [crates.io](https://crates.io/) に公開する
  - `cargo publish`
    - ワークスペースを使っている場合：--all フラグや-p フラグはないので、各クレートのディレクトリに移動して、 cargo publish する
  - Crates.io
    - オープンソースの Rust プロジェクトを投稿する場所
    - クレート名は早い者勝ち：一旦クレート名が取られてしまったら、 その名前のクレートを他の人が公開することはできない
- [crates.io](https://crates.io/) からバイナリをインストールする
  - `cargo install`
  - 独自のコマンドで Cargo を拡張する
    - `$PATH`にあるバイナリが`cargo-something`という名前なら、`cargo something`を実行することで、 Cargo のサブコマンドであるかのように実行することができる。このような独自のコマンドは、 `cargo --list`を実行すると、列挙もされる。
- リンク
  - [The Cargo Book](https://doc.rust-lang.org/cargo/index.html)

## 文、式、演算子、コメント

- 文（Statements）
  - なんらかの動作をして値を返さない命令
  - 例
    - 変数宣言（let キーワード）
      - NG 例: `let x = (let y = 6);`
    - 関数定義（fn キーワード）
- 式（Expressions / expr）
  - 評価され値になる
  - 終端にセミコロンを含まない
  - 例
    - 関数呼び出し
    - マクロ呼び出し
    - ブロック（`{}`）
    - if 式
- [演算子](https://doc.rust-lang.org/book/appendix-02-operators.html)
  - 演算子オーバーロード： 演算子に紐づいたトレイトを実装することで `std::ops` に列挙された処理と対応するトレイトをオーバーロードできます。
  - 独自の演算子は作成不可
- コメント
  - 通常のコメント
    - JavaScript と同じ（`//`, `/* */`）
  - ドキュメンテーションコメント
    - 利用者に向けた説明を記載する
    - 3 連スラッシュ（`///`）を使用
    - `cargo doc` を実行することで、HTML ドキュメントを生成する
    - マークダウンを使用できる
      - `#`（h1）としてよく使うものの例：
        - Examples
        - Panics：ドキュメント対象の関数が panic!する可能性のある筋書き
        - Errors：関数が Result を返すなら、起きうるエラーの種類とどんな条件がそれらのエラーを引き起こす可能性があるのか解説する
        - Safety：関数が unsafe なら、 その理由、及び、関数が呼び出し元に期待する条件を説明する
    - テストとしてのドキュメンテーションコメント
      - `cargo test` を走らせると、ドキュメントのコード例をテストとして実行する
        - ドキュメントの例のコードが間違っているということを防止できる
    - `//!`
      - クレートの目的を解説するドキュメンテーションを追加する

## ident（識別子）

### 変数

- `let` で不変の変数を宣言
  - `let x = 5;`
- `let mnt` で可変の変数を宣言
  - `let mut x = 5;`
- シャドーイング
  - 意義：前に定義した変数と同じ名前の変数を新しく宣言する
  - 効果：変数の型を変更できる
  - 例：`let mut x = x;`
  - shadow の主語と目的語：
    - 新しい変数（`=`の左側）は覆い隠す（shadow）する
    - 古い変数（`=`の右側）は覆い隠される（be shadowed）
- 初期値なしの宣言も可能
  - 例：`let r;`
  - ただし、値を与える前に変数を使用しようとすれば、コンパイルエラーになり、 これは、確かに Rust では null 値は許可されないことを示す

#### グローバル変数

Rust では静的変数（_static variables_） と呼ばれる

- ルール
  - 変数の型を注釈しなければならない
  - `'static`ライフタイムの参照のみ格納できる
    - Rust コンパイラがライフタイムを推量するので、注釈に`'static`を記載する必要はない
- 定数と不変な静的変数の差異
  - 静的変数の値は固定されたメモリアドレスになる
  - 定数は使用される度にデータを複製させることができる
- 定数と静的変数の差異
  - 静的変数は可変にもなる
    - 可変な静的変数にアクセスし変更することは、unsafe

### 定数

- `const` キーワードで宣言
  - 注釈（`:` + 型）が必須
  - `mut` キーワードは使えない
- グローバルスコープに定義可能
- 関数呼び出し結果や、実行時に評価される値はセットできない

## データ型

- 値は全て、何らかのデータ型に属する
- データ型はスカラー型と複合型に分けられる
- [プリミティブ型（_primitive types_）](https://doc.rust-lang.org/std/primitive/index.html)

### スカラー型

- 数値型
  - 整数型
    - 小数部分のない数値
    - [Rust の整数型はリンク先を参照](https://doc.rust-jp.rs/book-ja/ch03-02-data-types.html#%E6%95%B4%E6%95%B0%E5%9E%8B)
    - 整数リテラル
      - 数値以外で使える文字
        - 型接尾辞
          - 例：`57u8`
        - 見た目の区切り記号(visual separator)
          - 例：`1_000`
    - 整数型の基準は`i32`型
      - 64 ビットシステム上でも、通常はこの型が最速
    - `isize`と`usize`型は、プログラムが動作しているコンピュータの種類に依存
      - 64 ビットアーキテクチャなら、64 ビット、32 ビットアーキテクチャなら、32 ビットになる
    - 参考：
      - `String` は `Vec<u8>`のラッパであり、内部的には、符号なし 8bit の整数型の連続データ
  - 浮動小数点数型
    - 数値に小数点がついたもの
    - IEEE-754 規格に従って表現される
    - `f32` と `f64`
    - 基準型は `f64`
      - ∵ `f32` とほぼ同スピードにもかかわらず、より精度が高い
- 論理値型
  - `bool` と指定
  - `true` と `false`
- 文字型（char 型）
  - シングルクォートを使う
  - ユニコードのスカラー値を表す
    - U+0000 から U+D7FF までと U+E000 から U+10FFFF までの範囲

### 複合型

- 概要：複数の値を一つの型にまとめた型
- タプル型
  - 例: `let tup: (i32, f64, u8) = (500, 6.4, 1);`
    - 補足：
      - 複数の型が推論される可能性がある場合、型注釈をつけることが必須
      - パターンマッチングの一種
  - 分配（destructuring）
    - `let tup = (500, 6.4, 1); let (x, y, z) = tup;`
  - 要素へのアクセス：ピリオド`.`
    - `let tup = (500, 6.4, 1); let five_hundred = x.0; let one = x.2;`
- 配列型
  - 例：`let a = [1, 2, 3, 4, 5];`
  - 要素へのアクセス：JavaScript と同じ
    - `let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1];`
    - 無効なアクセス
      - **実行時**エラーとなる
      - 例：`let a = [1, 2, 3, 4, 5]; let second = a[10];`
  - 配列の全要素は、 同じ型でなければならない。
  - 固定長（動的な要素数の変更は不可）
  - 利用場面
    - ヒープでなくスタックを使う場合
    - 要素数が固定のデータを使う場合
      - 例: 年月日の月
  - JavaScript の配列は Rust のベクタ型に近い

## その他の型

### スライス型

- 特徴：
  - 所有権がない
  - データ型として扱われる
- 機能：コレクション全体ではなく、その一部を参照する
- 文字列スライス
  - 型：`&str`
    - String への参照（`&String`）型を代替することが可能
      - 例： `fn first_word(s: &String) -> &str` → `fn first_word(s: &str) -> &str`
    - 文字列リテラルの型（iow: 文字列リテラルは文字列スライス）
  - 文法：
    - コレクション + `[starting_index..ending_index]`
      - `starting_index` はスライスの最初の位置
      - `ending_index` はスライスの**終端位置よりも、 1 大きい**値
    - スライスの最初の要素が対象コレクションの最初の要素である場合の糖衣構文
      - `let slice = &s[0..2];`
      - `let slice = &s[..2];` （糖衣構文）
    - スライス最後の要素が対象コレクションの最後の要素である場合の糖衣構文
      - `let len = s.len(); let slice = &s[3..len];`
      - `let slice = &s[3..];` （糖衣構文）
    - 全て取得する場合
      - `&s[..]`
- 内部的データ構造：
  - アドレス：データへのポインタ（開始地点）
  - スライスの長さ：`ending_index` から `starting_index` を引いたもの
- 他のスライス
  - 例：
    - `let a = [1, 2, 3, 4, 5]; let slice = &a[1..3];`
      - 型：`&[i32]`

### ポインタ

- 意義：メモリのアドレスを含む変数
  - アドレス：何らかのデータを指し示す数値
- ポインタの種類
  - 参照：
    - `&`記号で表す
    - データを借用するだけのポインタ（指している値を借用するだけ（データを参照する以外のことはできない））
    - オーバーヘッドはない
    - 最も頻繁に使われる
  - スマートポインタ
    - データ構造（`Deref`と`Drop`トレイトを実装した構造体であることが多い）
    - ⇒ ポインタにはない、追加のメタデータを有する
  - 関数ポインタ

### 関数ポインタ

- 型：`fn`
  - 注意：`Fn`クロージャトレイトとの混同に注意
- 実装トレイト
  - 関数ポインタは、クロージャトレイト 3 つ全て(Fn、FnMut、FnOnce)を実装する
    - ⇒ クロージャを引数に取る関数に`fn`を渡すことが可能
- 引数の型としての`fn`のユースケース
  - クロージャのない外部コードとのインターフェイス
    - 例：C 関数は引数として関数を受け入れられるが、C にはクロージャがない

### struct（構造体 / structure）

- 概要：
  - 複数の関連した値を意味のあるグループにまとめる
  - 各フィールドに名前を付けられる
  - 独自の**データ型**として扱われる
- 補足：インスタンス全体が可変でなければフィールドを変更することはできない
- 効果：データ同士の関連性を示し、プログラムの意図を明示的にする
- 特殊な構造体
  - tuple structs（タプル構造体）: タプルを独自の型として扱う
  - unit-like structs：一切フィールドのない構造体
  - スマートポインタ
    - （`Deref`と`Drop`トレイトを実装した）構造体であることが多い
- 制約
  - 構造体に未代入のフィールドが存在してはいけない
    - ⇒ 構造体のフィールドから所有権を奪うには工夫が必要
      - 例：所有権を奪いたいフィールドを`Option`でラップし、`Option.take`メソッドで所有権を奪う（ch17-15 参照）

#### スマートポインタ

- 機能：所有権システムの例外として機能する
  - 例：
    - 参照カウント方式のスマートポインタ型
      - 所有者の数を追いかけ、所有者がいなくなったらデータの片付けをしてくれる
        - ⇒ データに複数の所有者を持たせることができる（所有権の保有者は一つという原則に対する例外）
- [ボックス](https://doc.rust-lang.org/std/boxed/struct.Box.html)
  - 型：`Box<T>`
  - 効果：スタックではなくヒープにデータを格納することができる
    - スタックにはヒープデータへのポインタをもつ
    - `Box<T>`値がスコープを抜けると、ボックスが参照しているヒープデータも片付けられる
  - オーバーヘッド：小さい
    - ∵ データをスタックの代わりにヒープに格納する以外のオーバーヘッドはない
  - 利用場面：
    - コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時
      - 例：cons list
    - 多くのデータがあり、その所有権を移したいが、その際にデータがコピーされないようにしたい時
      - 説明：多くのデータの所有権を転送するには、データがスタック上でコピーされるので、長い時間がかかり得る。この場面でパフォーマンスを向上させるために、多くのデータをヒープ上にボックスとして格納することができる。 そして、小さなポインタのデータのみがスタック上でコピーされる一方、それが参照しているデータはヒープ上の 1 箇所に留まります。
    - 値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけている時
      - トレイトオブジェクトとして知られる（c.f. 「トレイトオブジェクトで異なる型の値を許容する」）
- [参照カウント（reference counting）](https://doc.rust-lang.org/std/rc/struct.Rc.html)
  - 型：`Rc<T>`
  - 機能：値がまだ使用中かどうか決定する値への参照の数を追跡する
    - 値への（強）参照が 0 の時に drop が呼び出されたときに、値が解放される
    - 値への弱参照（_weak reference_）の数は値の解放有無に影響しない
      - ⇒ `Weak<T>`（`Rc::downgrade`の戻り値）が参照する値はドロップされてしまっている可能性があるので、`upgrade`メソッドを利用する
  - 比喩：家族部屋のテレビ：1 人がテレビを見に部屋に入ったら、テレビをつけます。 他の人も部屋に入ってテレビを観ることができます。最後の人が部屋を離れる時、 もう使用されていないので、テレビを消します。他の人がまだ観ているのに誰かがテレビを消したら、 残りのテレビ視聴者が騒ぐでしょう！
  - 利用場面：
    - ヒープにプログラムの複数箇所で読む何らかのデータを確保したいけれど、 コンパイル時にはどの部分が最後にデータを使用し終わるか決定できない時
      - なお：どの部分が最後に終わるかわかっているなら、 単にその部分をデータの所有者にして、コンパイル時に強制される普通の所有権ルールが効果を発揮するでしょう
  - 注意：
    - シングルスレッドの場合を想定したもの
      - `Rc<T>`の値をクローンし、 クローンしたものの所有権を別のスレッドに転送しようとしたら、両方のスレッドが同時に参照カウントを更新できてしまう
      - 代わりに、`Arc<T>`を使う
    - 循環参照を生成してしまうリスクがある
      - 2 つの `Rc<T>` の値がお互いを参照し合い、メモリリーク（絶対に片付けられることのないメモリ）を引き起こす可能性がある
- [内部可変性](https://doc.rust-lang.org/std/cell/struct.RefCell.html)
  - 型：`RefCell<T>`
  - 概要：
    - そのデータへの不変参照がある時でさえもデータを可変化できる
    - 保持するデータに対して単独の所有権を表す
  - 目的：プログラマが実行時においてエラーにならない（借用規則に従っている）ことを保証できるにも関わらず、静的解析ルール上コンパイルエラーとなってしまうプログラムをコンパイル可能にする
  - Box との違い：借用規則（※）を強制するタイミング
    - Box： コンパイル時
    - RefCell：実行時
      - 規則が破られた場合パニックを発生させる
    - ※ 借用規則：
      - 「1 つの可変参照」か「いくつもの不変参照」のどちらか一方のみが存在可能
      - 参照は常に有効でなければならない。
  - 注意：
    - シングルスレッドの場合を想定したもの
      - ⇒ 試しにマルチスレッドの文脈で使ってみようとすると、コンパイルエラーを出す
- [ミューテックス（_mutual exclusion_ / Shared-State Concurrency）](https://doc.rust-lang.org/std/sync/struct.MutexGuard.html)
  - 型：`MutexGuard<T>`
  - 生成方法：`Mutex<T>`の`lock`メソッド
  - Drop 実装：ロックを解除する
    - ⇒ ロックの解除が自動的に行われるので、ロックの解除を忘れを防止
  - 注意：
    - コンパイラはデッドロックが発生するリスクまで防げない
- その他
  - `Cell<T>`
  - `Weak<T>`
  - 自分だけのスマートポインタを書くこともできる
    - 多くのライブラリに独自のスマートポインタがある
- 組み合わせで実現できること：
  - 複数の所有者を持ち、かつ、可変化できる変数を得る
    - `RefCell<T>`を hold する`Rc<T>`（`RefCell<T>`を使用して`Rc<T>`の内容を可変化）
  - 複数のスレッドで所有権を共有しつつ、 スレッドに値を可変化させる
    - `Mutex<T>`を使用して`Arc<T>`の内容を可変化（ch16-3）

#### ニュータイプ（ニュータイプパターン）

- 概要：トレイトを実装したい型をタプル構造体でラップする
- 効果：
  - ラッパの型はクレートにローカルなので、オーファンルール（_orphan rule_）を回避できる
  - 他の型との住み分けをはっきりさせることができる（意図しない型との混同を静的に（コンパイル時に）チェックできる）
  - 内部の型が有しているメソッド等のプライバシーの変更、新しいメソッドの追加
  - 手軽にカプセル化（内部実装の隠匿）を実現できる
    - 例：`HashMap<i32, String>`を`People`型としてラップ
- 用語の由来：Haskell プログラミング言語に端を発する
- 欠点
  - ラッパが新しい型なので、保持している値のメソッドがない
    - ラッパに対して内部の型のメソッドを実装しようとすると直接手動で実装しなければならない
    - ← ラッパの内部の型が持つ全てのメソッドを新しい型に持たせたいなら、 Deref トレイトをラッパに実装して、 内部の型を返すことは解決策の 1 つ

### Enum

- **取りうる値すべて**を列挙する
- enum の値は、その列挙子（_variants_）のいずれか一つになる
- 独自の**データ型**を形成する
- `impl`を使ってメソッドを定義できる
- コンパイラが、プログラマが処理すべき場面全てを処理しているかどうかをチェックできるようになる

### メソッド （Method Syntax）

- 関数との違い：
  - 特定の文脈で定義される
    - 文脈：
      - struct
      - enum
      - trait object
  - 第一引数には必ず`self`を使う
    - `self` の書き方：
      - `&self`: 読込み専用（インスタンスのデータを読み込みたいだけ）
      - `&mut self`: 読込み＋書込み（メソッドを呼び出したインスタンスを変更したい）
      - `self`: 所有権奪取（self を何か別のものに変形し、変形後に呼び出し元が元のインスタンスを使用できないようにしたい場合など限られた場面でのみ使う）
        - 例：ステートパターン（ch17-3）
- 関数の代替としてメソッドを使う主な利点：
  - 特定の型を繰り返し書かずに済む（代わりに self キーワードを書く）
  - ある特定の型のインスタンスを使ってできることを`impl`ブロックにまとめて体系化できる
- メソッドでは _automatic referencing and dereferencing_ （自動参照・自動参照外し機能）が発動する
  - `pointer.something()` と書ける
  - 以下のようには書か**ない**
    - `pointer->something()`
    - `(*pointer).something()`
- _associated functions_ （関連関数）：
  - 概要：特定のオブジェクトではなく特定の型に対して実装された関数
    - impl ブロック内の self を引数に取らない関数
    - メソッドではない
  - 類似：クラスのスタティックメソッド
  - 呼び出し方：構造体名 + `::` + 関連関数 （例：`String::from`）
  - 用途：
    - 名前空間を分ける
    - 構造体の新規インスタンスを返すコンストラクタ（例：`new`）

### コレクション

- 複数の値を含むことができる
- コレクションが指すデータはヒープに確保される
  - 組み込みの配列とタプル型とは異なる
  - データ量はコンパイル時にわかる必要はなく、 プログラムの実行にあわせて、伸縮可能
- 種類（各種のコレクションから状況に応じた最適なものを選び取る）
  - ベクタ型：可変長の値を並べて保持
  - 文字列：文字のコレクション
  - ハッシュマップ：
    - 値を特定のキーと紐付ける
    - より一般的なデータ構造であるマップの実装の一つ
  - [その他](https://doc.rust-lang.org/std/collections/index.html)

#### ベクタ（`Vec<T>`）

- データ構造：
  - メモリ上に値を隣り合わせに並べる
- 制約
  - 同じ型の値しか保持できない
    - ∵ 各要素を格納するのには、ヒープ上にどれくらいのメモリが必要になるか正確に把握するため
    - ⇒ 副次的な利点：ベクタでは、どんな型が許容されるのか明示できる
      - enum をつかって複数の型を保持する場合でも、match 式を使えば、コンパイル時にあり得る可能性をチェックすることが可能
    - Enum と組み合わせると複数の型を保持できる
- 生成：`let v: Vec<i32> = Vec::new();`
  - ※ TypeScript と同様、値がない場合は当然ジェネリックは効かないので、型注釈が必要
  - マクロによる生成：`let v = vec![1, 2, 3];`
    - ※TypeScript と同様、初期値が与えられれば型注釈は必要ない
- 更新：`push`メソッド
  - 例：`let mut v = Vec::new(); v.push(5);`
    - ※ TypeScript とは異なり、生成後でもコンパイルが型を推論してくれるので注釈は必要でなくなる（NOTE）
- 破棄：スコープを抜ければ自動的に（その中身も）破棄される（ドロップ）
- 取得：`let v = vec![1, 2, 3, 4, 5];`を前提とすると...
  - 添字記法（indexing syntax）：`let third: &i32 = &v[2];`
    - 存在しない要素を参照するとパニックが発生する
  - get メソッド：`let third: Option<&i32> = v.get(2);`
- 内部動作：
  - 新規要素をベクタの終端に追加する場合
    - ベクタが現在存在する位置に隣り合って要素を入れるだけの領域がなかった場合
      - 新しいメモリを割り当て、古い要素を新しいスペースにコピーする
- リンク：
  - [the API documentation](https://doc.rust-lang.org/std/vec/struct.Vec.html)
  - [What is the difference between storing a Vec vs a Slice?](https://stackoverflow.com/a/32573802)

#### 文字列

- 構成：
  - バイトのコレクション
  - それらのバイトをテキストとして解釈した時に有用なメソッド
- 文字列スライス（`str`）
  - 立ち位置：Rust 言語の核として組み込まれている
  - 型：通常借用された形態`&str`で目にする
  - 性質：
    - UTF-8 encoded
  - 実体：UTF-8 エンコードされた文字列データへの参照
    - 文字列データ格納場所：
      - 文字列リテラルの場合：プログラムのバイナリ出力に格納される
- `String`型
  - 立ち位置：Rust の標準ライブラリで提供される
  - 型：`String`
  - 性質：
    - UTF-8 encoded
    - growable, mutable, owned
  - 実体：`struct String { vec: Vec<u8> }`
    - リンク：[std::string::String](https://doc.rust-lang.org/std/string/struct.String.html)
  - 慣例：Rust における「文字列（"string"）」とは、`String`**と**文字列スライス（`&str`）のことであり、どちらか一方ではない
  - 型強制（_coerce_）：
    - コンパイラは`&String`引数を`&str`に型強制する
      - `s` を `String` とすると、`&s` は `&s[..]` に変換されると考えられる
  - メソッド
    - `add` （`+` 演算子でコール可能）
      - 注意：add の第一引数（`+`の左側）は所有権を奪われる
        - ⇒ ∵ 実行効率のため
  - 添え字アクセス
    - 不可（コンパイルエラーとなる）
      - 理由：
        - `String` は `Vec<u8>`のラッパであり、このデータの表現方法として、バイト値、文字、書記素クラスタ（人間が文字と呼ぶものに一番近い）など複数考えられる。例えば、ある文字列はバイト列として見ると 18 バイト、Unicode スカラー値としてみたら 6 つの`char`、書記素クラスタとして見たら、4 つの文字となったりする。添え字でアクセスする場合、どの表現を前提としてアクセスするのか不明確。
        - データとしてはただのバイト列なので、データの並びに index でアクセスするとバイト値を返すことになるが、これは文字を扱いたいユーザーの望む動作ではないことは明らか
          - かといって書記素クラスタ等で処理するにはデータの走査が必要になり、「添え字アクセスは`O(1)`である」という期待に反する動作になってしまう
  - スライス
    - 文字の境界で適切にスライスしないとパニックを発生させる
  - 走査
    - `chars`メソッド：`char`型のイテレータを返す
    - `bytes`メソッド：各バイトのイテレータを返す
  - 補足
    - 書記素クラスタ
      - 文字列から得る方法は複雑なので、この機能は標準ライブラリでは提供されていない
      - 必要な場合、crates.io からクレートを探す
  - マクロ
    - `format!`
      - println!と同様の動作をしますが、 出力をスクリーンに行う代わりに、中身を String で返す
      - format!を使用したコードは引数の所有権を奪わない
- その他
  - OsString
  - OsStr
  - CString
  - CStr
- Rust の文字列の取り扱いのメリット
  - ASCII 以外の文字に関するエラーを開発の後半で扱わなければならない可能性が排除されている
    - （開発の最初の時点で（本来的に複雑なデータである）文字列に正面から向き合う必要がある）

#### ハッシュマップ

- 型：`HashMap<K, V>`
- 機能： `K`型のキーと`V`型の値の対応関係を保持
- 他の言語における名称：hash、map、object、ハッシュテーブル、連想配列などなど
- キー（`K`）：
  - どんな型にもなりうる
  - 全て同じ型でなければなりません。
- 値（`V`）：
  - 全て同じ型でなければなりません。
- マクロ：なし
- 補足：
  - 型注釈でアンダースコアを使用：コンパイラに、ベクタのデータ型に基づいてハッシュマップが含む型を推論させる
- ハッシュ関数
  - 役割：キーと値のメモリ配置方法を決める
  - デフォルト：サービス拒否(DoS)アタックに対して抵抗を示す暗号学的に安全なハッシュ関数を使用
    - ○：安全性が高い
    - ×：利用可能な最速のハッシュアルゴリズムではない
  - 異なる hasher を指定することで別の関数に切り替えることができる
    - hasher：BuildHasher トレイトを実装する型

### 型エイリアス（_type alias_）

- 文法
  - 例：
    - `type Thunk = Box<Fn() + Send + 'static>;`
    - `type Result<T> = std::result::Result<T, std::io::Error>;`
- ユースケース
  - 繰り返しを減らす
  - 意味のある名前付けることで型の意図を伝える

### never 型

- 特徴：他のどんな型にも型強制され得る
  - ⇒ どのような文脈の`match`式でも利用可能
  - ⇒ どのような戻り値の型の関数でも返却可能
- 記法：`!`
  - 例：`fn bar() -> ! { --snip-- }`
    - なお、`never`を返す関数は、発散する関数(_diverging function_)と呼ばれる
- ユースケース
  - match 式のアームで利用する
- 具体例：
  - `continue` の型
  - panic!マクロ（`unwrap`関数）
  - `break` を含まない `loop` 式

### Dynamically Sized Types （動的サイズ決定型、DST、サイズなし型（_unsized types_））

- 概要：実行時にしかサイズを知ることのできない値の型
- 制約：なんらかの種類のポインタを利用する必要がある
  - 背景：Rust では、特定の型のどんな値に対しても確保するメモリ量を知る必要があり、ある型の値は全て同じ量のメモリを使用しなければならないが、DST ではこれが不可能であるため、ポインタを用いる必要がある
  - 例：
    - `str`
      - `&str` として利用する（`Box<str>`なども可能）
    - トレイト
      - `&Trait`や`Box<Trait>`などとして利用する
- `Sized`トレイト
  - 概要：
    - DST を扱うためのトレイト
    - 型のサイズがコンパイル時にわかるかどうかを決定する
  - コンパイル時の特殊な動作
    - コンパイル時にサイズの判明する全てのものに自動的に実装される
    - コンパイラは暗黙的に全てのジェネリックな関数に Sized の境界を追加する
      - `fn generic<T>(t: T) {` → 変換 → `fn generic<T: Sized>(t: T) {`
        - ⇒ ジェネリック関数はコンパイル時に判明するサイズがある型に対してのみ動作する
          - 制限の緩和
            - 「T は Sized かもしれないし、違うかもしれない」という解釈の仕方へ変更する
            - 記法：`fn generic<T: ?Sized>(t: &T) {`（
              - この記法は、Sized にのみ利用可能

## フロー制御

- 条件式
  - bool 型でなければならない（論理値以外の値が、自動的に論理値に変換されることはない）
- if 式
  - `if` + 条件式 + `{}`
  - `if` + 条件式 + `{}` + `else` + `{}`
  - `if` + 条件式 + `{}` + ...[`else if`+ 条件式 + `{}`] + `else` + `{}`
- 繰り返し
  - `loop` + `{}`
    - ブロック内を無限ループさせる
    - `break` で抜ける
  - `while` + 条件式 + `{}`
  - `for` + 変数 + `in` + イテレータ + `{}`
- if let 式
  - 値が一つのパターンにマッチした時にコードを走らせ、 他は無視する match の糖衣構文と言える
- match 式
  - `match` はフロー制御演算子
  - 全てのありうるパターンを網羅していない場合はコンパイルエラーとなる
  - 文法：`match` + マッチ対象の値 + `{` + ...アーム `}`
    - アーム
      - 制約：全て同じ型を返す必要がある
        - 例外：never 型
      - 文法：パターン [ + マッチガード] + `=>` + 式 [ + `,`]
      - パターン
        - リテラル値、変数名、ワイルドカード、その他
        - ワイルドカード（`_`／プレースホルダ）
          - 機能：
            - 全てにマッチ
              - ⇒ 網羅性の保証が可能になる
          - 比喩：case 文の default ラベル みたいなもの
        - `ref` キーワード（TODO: 最新版（英語版）の確認）
          - 値にマッチし、それへの参照を返す
          - ムーブを防ぐ
        - `&`
          - 参照にマッチ
      - マッチガード：
        - アームのパターンに追加できる条件式
        - アームのコードが実行されるにはマッチガードが真でなければいけない
    - ルール
      - match 式の値の可能性全てが考慮されなければならない（網羅的である必要がある）
  - 補足：
    - match 式 は primitive な操作であり、あまりネストすることは好まれない（Listing 9-5 参照）
      - 代わりに match 式 の役割をラップしたメソッド（`unwrap_or_else`など）を使うと良い
- 論駁可能性：「パターン」には 2 つの形態がある: 論駁可能なものと論駁不可能なもの
  - エラーメッセージに`irrefutable`と`refutable`という文言で登場する場合がある。
  - 論駁不可能（_irrefutable_）
    - 渡される可能性のあるあらゆる値に合致するパターン
    - 受け入れるもの：let 文、for ループ
  - 論駁可能（_refutable_）
    - なんらかの可能性のある値に対して合致しないことがあるパターン
    - 受け入れるもの：if let と while let 式

## コンパイル時におけるメモリ安全性の保証

### メモリ

- メモリ管理：ガベージコレクタ(GC)、allocate と free、所有権システムの３つ
  1. ガベージコレクタ(GC)
     - メモリ確保・解放を明示的に行う必要がなく便利
     - 動作が遅くなる
     - memo：メモリの制御は不可能（完全に自動）
  2. プログラマによる allocate と free（プログラマが明示的にメモリを確保・解放する）
     - メモリの確保・解放は歴史的にも難しいプログラミング問題の一つ
       - allocate と free は完全に 1 対 1 に対応していないといけない
         - free が重複すると**二重解放エラー**（メモリ安全性上のバグの一つ）となる
     - memo：メモリの制御は手動
  3. 所有権システム
     - Rust 独自
     - メモリを所有している変数がスコープを抜けたら、 メモリは自動的に解放（これを「drop / ドロップ」という）される
     - 慣れれば安全かつ効率的なコードを構築できる
     - memo：特定のルールに従うことでメモリの制御が可能。
- スタックとヒープ
  - 実行時にコードが使用できるメモリの一部
- スタック
  - データアクセスが高速
    - 理由 1：last in, first out だから
    - 理由 2：スタック上のデータは全て既知の固定サイズだから
  - 配置されるデータ
    - 関数のローカル変数（ポインタ + α）等
    - コンパイル時に存在が確定している固定長データ（リテラル）
- ヒープ
  - データアクセスが低速
    - 理由：データが飛び飛びの場所にある（隔離されている）場合があるから
  - 配置されるデータ
    - コンパイル時にサイズがわからなかったり、サイズが可変のデータ
  - allocate（on the heap）の構成
    - データのスペースの確保
    - スペースへのポインタの取得
- 関数とメモリ
  - 関数開始時（呼び出し時）
    - 関数に渡された値（or ヒープのデータへのポインタ）と、 関数のローカル変数がスタックに配置される
  - 関数終了時
    - スタックに配置されたデータはスタックから取り除かれる。
- スコープ
  - 変数は宣言された地点から、宣言されたブロックの終わりまで有効
- 文字列
  - 文字列リテラル
    - 静的、不変（中身はコンパイル時に判明しているので、テキストは最終的なバイナリファイルに直接ハードコードされる）
      - ⇒ 高速、効率的、`'static`ライフタイム
    - 文字列スライスの一種
  - String 型
    - 動的、可変
      - ヒープにメモリを確保される

### 所有権

- 所有権システム
  - 機能
    - どの部分のコードがどのヒープ上のデータを使用しているか把握する
    - ヒープ上の重複するデータを最小化する
    - メモリ不足にならないようにヒープ上の未使用のデータを掃除する
  - ルール
    - Rust の値は、**所有者**（owner）と呼ばれる変数と対応している
    - いかなる時も所有者は一つである
    - 所有者がスコープから外れたら、値は破棄される
  - 効果
    - 並行プログラミングでエラーを回避する
      - （所有権システムを作成した段階では未発見の効果だったが、所有権システムは並行プログラミングにも有効であることが後から分かった）
      - ある意味では、どんなプログラミング言語のチャンネル（メッセージ受け渡しの仕組み）も単独の所有権に類似しています。 一旦チャンネルに値を転送したら、その値は最早使用することがないからです。
        - Rust においては、並行プログラミングは、もはや恐れるべき概念ではありません
        - Rust『オレにとって「並行プログラミング」は　昼下がりのコーヒーブレイクと何ら変わらない平穏なものだ』
- ムーブ（Move）
  - memo：ムーブでは、スタックメモリのみが変化する
  - 例:
    - `let s1 = String::from("hello");`
      - スタック
        - s1: { ptr: ピープへのポインタ, len: 5, capacity: 5 }
      - ヒープ
        - (index, char) × len
    - `let s1 = s1;`
      - スタック
        - s1: { ptr: ピープへのポインタ, len: 5, capacity: 5 } （無効化（invalidate）される）
        - s2: { ptr: ピープへのポインタ, len: 5, capacity: 5 } （コピーされる）
      - ヒープ
        - (index, char) × len （ヒープのデータはコピーされない）
  - Rust では、 自動的にデータの _deep copy_ が行われることは絶対にない
    - ⇒: 実行時性能が良い
    - ⇒: _deep copy_ をしたい場合、`clone`メソッドを使う
- コピー（Copy）
  - 例:
    - `let x = 5;`
    - `let y = x;`
    - `println!("x = {}, y = {}", x, y);` （← 有効）
  - 静的に確定している値はムーブではくコピーされる
    - memo：静的に確定している値は allocate が不要なので、「コピー元変数無効化による二重解放エラー」に対する心配は無用
  - ムーブではなくコピーとなる型
    - あらゆる数値型
    - 論理値型, 文字型
    - コピーとなる型から構成されるタプル
- 所有権と関数
  - 別の変数に値が移る場面ではムーブ（or コピー）が生じる
    - 具体例 1：関数に変数を渡すことでムーブ（or コピー）が生じる
    - 具体例 2：関数の戻り値として評価される変数にもムーブ（or コピー）が生じる

### 参照と借用

- 参照
  - 作成方法：`&`演算子
  - ルール：
    - 参照は常に有効なデータを指していなければならない
      - ⇒ ダングリングポインタは作成できない
  - プログラムに有効な参照がある場合、借用チェッカー（borrow checker）が所有権と借用規則を強制する
  - 機能：参照の受け渡しはムーブを生じない
- 借用（borrowing）
  - 意義：参照を作成すること（参照を受けること？）
    - 例: `fn calculate_length(s: &String) -> usize { s.len() }`
      - memo：上記例ではメソッド呼出しにおいて「自動参照および参照外し（automatic referencing and dereferencing）」が使われている
  - 機能：所有権を奪わない
- 不変参照（immutable references）
  - 例：`&x`
  - 特定のスコープに内に、いくつでも作ることができる。
- 可変参照（mutable references）
  - 例：`&mut x`
- 借用規則 1：一つのデータに対する参照の参照スコープ（reference’s scope）が重なってはいけない
  - 目的：データ競合をコンパイル時に検知・防止する
    - データ競合
      - 意義：未定義の振る舞いを引き起こし、実行時に追いかけようとした時に特定し解決するのが難しい問題
      - 発生条件：
        - 2 つ以上のポインタが同じデータに同時にアクセスする
        - 少なくとも一つのポインタがデータに書き込みを行っている
        - データへのアクセスを同期する機構が使用されていない
- 借用規則 2：一つのデータに対する可変参照と不変参照の参照スコープ（reference’s scope）が重なってはいけない
  - 目的：不変参照利用側に対する不意打ち防止
    - 解説：不変参照に利用者がいる場合、その利用者は参照先の値が変わらないことを想定している。それにもかかわらず、値を変更するため参照が同時に存在すると不変参照の利用者の期待をが害することになる。
- 借用規則の例外：
  - 生ポインタ
  - std::cell::RefCell を利用するとコンパイル時の借用規則違反を無視できる
- 参照スコープ（reference’s scope）：意図しない値の変更の防止
- _dangling pointer_（ダングリングポインタ）
  - 意義：すでに解放（free）されてしまったメモリを参照するポインタ
  - Rust ではコンパイルエラーとなるため、発生しない

## モジュールシステム

- パッケージ：クレートをビルドし、テストし、共有することができる Cargo の機能
- クレート：ライブラリか実行可能ファイルを生成する、木構造をしたモジュール群
- モジュール と use：これを使うことで、パスの構成、スコープ、公開するか否かを決定できます
- パス：要素（例えば構造体や関数やモジュール）に名前をつける方法
- アイテム：関数、メソッド、構造体、列挙型、モジュール、および定数
  - memo：「item」を「要素」と訳すと element の訳と被るので、「アイテム」と記載

### クレート

- クレートルート（_crate root_）：Rust コンパイラの開始点となり、クレートのルートモジュールを作るソースファイル
  - 例：
    - src/main.rs
    - src/lib.rs
- 種類：バイナリかライブラリのどちらか
  - バイナリクレート
    - 実行可能形式
    - 単体で実行することを意味する
      - ⇒ 他のクレートから呼び出されない
  - ライブラリクレート
    - 他のプログラム（クレート）が呼び出して使用できる関数を公開する
- キーワード
  - `extern crate`
    - 効果：ライブラリクレートをスコープに導入する
    - 例： `extern crate add_one;`
      - 別のワークスペースにあるライブラリクレートを利用する場合`Cargo.toml`ファイルの`[dependencies]`欄に追加する必要がある
        - 例：`add-one = { path = "../add-one" }`

### パッケージ

- 意義：ある機能群を提供する 1 つ以上のクレート
- 特徴：Cargo.toml ファイルを持つ
- ルール：
  - パッケージは少なくとも 1 つのクレートを持たなければならない
  - **ライブラリ**クレートを 2 個以上持つことはできない
  - **バイナリ**クレートはいくらでも持っていて良い
- Cargo.toml
  - 概要：クレートをどのようにビルドするかを説明するファイル
  - セクション（キー）
    - `[profile.*]`セクション
      - 無い場合：Cargo のデフォルト設定が利用される
      - 有る場合：Cargo のデフォルト設定を上書きする
    - `[package]`
      - `edition`キー
        - コンパイラがどのエディションを適用すべきかを指定する（後方互換性のため、デフォルトでは`2015`）
- ワークスペース
  - 目的：協調して開発された関連のある複数のパッケージを管理する
  - 意義：同じ Cargo.lock と出力ディレクトリを共有する一連のパッケージ
  - ワークスペースで`cargo test`を走らせると、ワークスペースの全クレートのテストを実行する
    `-p`フラグを使用し、テストしたいクレートの名前を指定することで最上位ディレクトリから、 ワークスペースのある特定のクレート用のテストを実行することもできる

#### プロファイル

- 意義：コンパイルオプションの設定
- `dev`プロファイル
  - `[profile.dev]`で設定
  - `cargo build` コマンドを実行したときに使用される
  - デフォルトで開発中に役に立つ設定がされている
- release プロファイル
  - `[profile.release]`で設定
  - `cargo build --release` コマンドを実行したときに使用される
  - デフォルトでリリースに役に立つ設定がされている
- 設定
  - `opt-level`設定
    - 0~3 の範囲でコンパイラがコードに適用する最適化の度合いを制御
      - 最適化を多くかけると、コンパイル時間が延びる

### モジュール

- 効果：クレート内のコードをグループ化し、可読性と再利用性を上げる
- 比喩：ファイルシステムのディレクトリ
- 機能：
  - ネストできる
    - ⇒: モジュールツリーを形成できる
  - アイテムの _privacy_ の制御
    - iow: *privacy boundary*の定義
    - ⇒: 関数や構造体といった要素を非公開にしたければ、モジュールに入れればよい
- 関連概念
  - _privacy_：
    - 意義：外部で使える (公開 _public_) のか、使えない (非公開 _private_) のかというアイテムの性質
    - デフォルト：_private_ （非公開）
      - memo: _private_ のメリット：非公開にしたコードは外部のコードを壊さないので、変更時に影響範囲を把握するのが楽
      - `pub` キーワードで公開（_public_）に変更可能
    - 親子間のプライバシー
      - 親モジュールのアイテムは子モジュールの非公開アイテムを参照できない
      - 子モジュールのアイテムはその祖先モジュールのアイテムを参照できる
        - ∵: 子モジュールは自分が定義された文脈を把握できる
    - 兄弟間（同じモジュール内で定義されているアイテム）のプライバシー
      - デフォルトで（非公開でも）互いに参照可能
    - 構造体：構造体のプライバシーと構造体のフィールドのプライバシーは別
    - Enum：Enum を公開すると列挙子も公開される
  - _privacy boundary_（プライバシー境界）：外部のコードが呼び出したり、依存したりしてはいけないかどうかのライン
- シンタックス：`mod` + モジュール名 + `{` + アイテム（モジュールを含む） + `}`

### パス

- 意義：モジュールツリー内のアイテムを取得する
- シンタックス：
  - スタートとなる識別子：
    - 絶対パス：
      - クレートの名前
      - `crate`
    - 相対パス：
      - `self`
      - `super`
        - ファイルシステムパスの`..`と同じ
        - `super::super::foo` と連続させることも可能
      - 今のモジュール内の識別子
  - 一つ以上の識別子をダブルコロン（`::`）で仕切る
- 補足：
  - 相対パスを使うか絶対パスを使うかは、プロジェクトによって決めましょう。
    - あるアイテムを定義するコードを移動させる場合、そのアイテムを使うコードと...
      - **別々に**移動させる可能性が高い => 絶対パス
      - **一緒に**移動させる可能性が高い => 相対パス
- `use` キーワード
  - 効果：パスをスコープに持ち込み、それ以降はパス内の要素がローカルにあるかのように呼び出すことができる
  - 文法：
    - `use` + パス [ + `as` + 名前] + `;`
      - 例：
        - `use std::collections::HashMap;`
        - `use std::io::Result as IoResult;`
    - nested paths： use 文の数を減らせる
      - 例 1
        - not nested:
          - `use std::cmp::Ordering;`
          - `use std::io;`
        - nested: `use std::{cmp::Ordering, io};`
      - 例 2
        - not nested:
          - `use std::io;`
          - `use std::io::Write;`
        - nested: `use std::io::{self, Write};`
    - ファイルの先頭で宣言する必要はない
  - 比喩：ファイルシステムにおいてシンボリックリンクを張る
  - 慣例：
    - 種類別：
      - 関数：関数の親モジュールを use する
      - 構造体・Enum：個別にそれ自体を use する
    - 補足：慣例はあくまでも慣例であり、はっきりとした理由はない
    - 名前の衝突の回避（以下のどちらでもよい）
      - 親モジュールを use する
      - 衝突する名前のどちらかに as を用いて名前を返る
  - 再エクスポート（re-exporting）
    - 意義：ある場所の公開要素を一つ取り、別の場所で定義されているかのように別の場所で公開する
    - `pub use` を用いる
    - 自分の API を現状の（非公開）構造とは異なる構造で公開できる
  - memo:
    - [プレリュード](https://doc.rust-lang.org/std/prelude/index.html)（prelude ＝ Rust がすべての Rust プログラムに自動的にインポートするもののリスト）に含まれているものは use する必要はない
    - `std`（標準ライブラリクレート）は `crates.io` からダウンロードする必要はないが use する必要がある
  - glob 演算子 `*`
    - 効果：パスにおいて定義されているすべての公開要素をスコープに持ち込む
    - 用途：
      - テスト対象の use

## エラー処理

- Rust では、エラーは大きく二つに分類されます: 回復可能なエラーと回復不能なエラー
  - 回復可能なエラー：`Result<T, E>`値で処理
  - 回復不能なエラー：`panic!`マクロで処理
    - panicked：プログラムがエラーで終了したことを表す Rust 用語
  - Rust には例外が存在しない
    - プログラムを終了させる手段（`panic!`）はあるが、例外をキャッチするといった機能は無い

### 回復不能なエラー

- `panic!`マクロ
  - 機能：
    - 失敗メッセージの表示
    - マクロを使用したソースコードの位置の表示
    - スタックを巻き戻し掃除して、終了
- バックトレース：
  - panic マクロ呼出し元に至るまでに呼び出された全関数の一覧
  - `RUST_BACKTRACE`環境変数でトレースする数を調整可能
  - OS や Rust のバージョンによって、出力の詳細は変わる可能性がある
- デバッグシンボル：
  - バックトレースを得るかどうかの設定
  - `--release`オプションなしで `cargo build` や `cargo run` を使用していれば、標準で有効

#### パニックに対する対処法

「巻き戻し」と「異常終了」とが存在する。

- Cargo.toml ファイルによって選択が可能
  - [profile]欄：
    - `panic = 'abort'`：異常終了
- 巻き戻し：
  - 言語がスタックを遡り、 遭遇した各関数のデータを片付ける
  - すべきことが多い
    - ⇒ 実行可能ファイルを大きくする
- 異常終了：
  - 片付けをせずにプログラムを終了させる
  - プログラムが使用していたメモリは、 OS が片付ける
    - ⇒ 実行可能ファイルを小さくする

リリースモード時に異常終了するようにしたければ、Cargo.toml ファイルに以下を追記する。

```rust
[profile.release]
panic = 'abort'
```

### 回復可能なエラー

Result Enum を使用する

- match を用いて自分で制御する
- Result 型のメソッドを利用する
  - unwrap
    - Result 値が Ok 列挙子なら、Ok の中身を返す
    - Result が Err 列挙子なら、 panic!マクロを呼ぶ
  - expect
    - panic!のエラーメッセージを渡せる unwrap
- エラーの伝播（_Propagating Errors_）：関数の戻り値を Result 型にして、結果を制御する役割（or 権限）を呼出し元に移譲する
  - `?`演算子：Propagating Errors のショートカット
    - 文法： `Result` + `?` + `;`
      - Result が Ok ならその中身として評価され、プログラのを継続する
      - Result が Err なら、「`return` + from で変換された Err」のような動作になる
        - `?`演算子が`from`関数を呼び出す
          - エラー型が現在の関数の戻り値型で定義されているエラー型に変換される
        - `?`演算子が変換されたエラー型を`return`する
    - 制約：`?`演算子は、Result（or Map）を返す関数でしか使用できない
      - main 関数は、戻り値が()なので main 関数内で`?`演算子は使えない

### panic! or Result

- Result が第一候補（出来るだけ Result を使うべき）
  - Result を使えば、呼び出す側は、panic! を使うか、プログラムの実行を継続するかを選択することができる
- `panic!`を使う場合
  - リリース前の特定の場合
    - プロトタイプの場合、あまり堅牢に作らなくてもよいから panic!で済ませてしまうのも一つの手段
      - 実際に開発段階に入った段階で、panic! を使う部分を修正していく
    - テストコードの場合は、panic! ですぐに失敗を知らせるようにするのも手段として有効
  - コードが悪い状態に陥る可能性があるとき
    - iow: 呼出し側のプログラマにコードを書き直させる必要がある場合
    - ※ 悪い状態（_bad state_）：
      - 何らかの前提、保証、約束、不変性が破られた状態（例えば、無効な値、 矛盾する値、欠損値がコードに渡された状態）
      - または以下を１つ以上満たす場合
        - 悪い状態に陥ることが予期できる場合？（TODO ここは理解ができてない／悪い状態 is「偶然起こることが予想される事象」でない）
        - この時点以降、この悪い状態にないことを頼りにコードが書かれているとき。
        - 使用している型にこの情報をコード化するいい手段がないとき。
    - 例：
      - ライブラリの開発者が利用者に対して、「利用方法間違ってるよ」と知らせたい場合
      - セキュリティーの観点から実行すべきでないことを呼出し元に伝える場合（境界外へのメモリアクセス（データ構造に属しないメモリにアクセスを試みられた）など）
- `unwrap`を使う場合
  - ある Result について、Ok になることが、（静的に）確定的な場合
    - 例えば、コンパイラはある文字列リテラルの内容・意味を理解できない。このように、プログラマはコンパイラよりも多くの情報を持っている。そのため、コンパイラにとっては Result は分からないが、プログラマにとっては確定的に Ok と判断できる場合もある。

## ジェネリクス

- 概念の重複を効率的に扱う道具
- 具体型や他のプロパティの抽象的な代役
- 関数、構造体、enum、メソッドなどのアイテムを定義する際に使用できる
- コードで多くのジェネリックな型が必要な時は、 コードの小分けが必要なサインかもしれない
- rust では、コードの単相化をコンパイル時に行うことで、具体的な型があるコードよりもジェネリックな型を使用したコードの方が遅くならないようにしてある
  - 単相化（monomorphization）は、コンパイル時に使用されている具体的な型を入れることで、 ジェネリックなコードを特定のコードに変換する過程のこと
    - iow: コンパイラは、ジェネリックなコードが呼び出されている箇所全部を見て、 ジェネリックなコードが呼び出されている具体的な型のコードを生成する
    - iow: ジェネリックなコードを実行すると、 それぞれの定義を手作業で複製した時のように振る舞う
    - 単相化の結果吐かれるコードは、 スタティックディスパッチを行う
    - 対照：
      - ダイナミックディスパッチ：
        - コンパイラは、実行時に、トレイトオブジェクト内でポインタを使用して、どのメソッドを呼ぶか知る
          - ⇒ 実行時コストあり

## トレイト

- 大要：共通の振る舞いを定義する
- 機能：ジェネリックとトレイトを組み合わせることで、ジェネリック型を、「特定の振る舞いのある型」に制限できます。
- 類似：TypeScript において interface を class で implement するのと似ている
- 文法：
  - トレイト定義：`trait` トレイト名 { シグネチャのみ or デフォルト実装 }
  - トレイト実装：`impl` トレイト名 `for` 構造体名 { 実装 }
  - ブランケット実装：`impl<T: トレイト名>` トレイト名 `for` `T` { 実装 }
- 制約：
  - コヒーレンス（_coherence_ ／ 孤児のルール（_orphan rule_））：外部のトレイトを外部の型に対して実装することはできない
    - ⇒ 他人のコードが自分のコードを壊したり、その逆ができないことを保証
    - この制約がなければ、2 つのクレートが同じ型に対して同じトレイトを実装できてしまい、 コンパイラはどちらの実装を使うべきかわからなくなってしまう
- 注意：デフォルト実装メソッドをオーバーライドしている実装からそのデフォルト実装メソッド呼び出すことはできない
- 引数としてのトレイト：
  - 文法：
    - 関数定義：
      - impl Trait 構文 1：`fn` 関数名(引数: ` &``impl ` Trait) { 実装 }
      - impl Trait 構文 2：`fn` 関数名(引数: `&`(`impl` Trait + Trait)) { 実装 }
      - トレイト境界構文：
        - 例 1：`fn` 関数名`<T:` Trait `>`(引数: `&T`) { 実装 }
        - 例 2：`fn` 関数名`<T:` Trait + Trait`>`(引数: `&T` , 引数: `&T`) { 実装 }
        - 例 3：`fn` 関数名`<T, U>`(引数: `&T`, 引数: `&U`) -> 戻り値型 `where` `T`: Trait + Trait, U: Trait + Trait { 実装 }
    - メソッド定義：
      - 例：`impl` `<T:` Trait1 `+` Trait2`>` 構造体名`<T>` { `fn` メソッド名(`&self`) { 実装 } }
        - この場合、Trait1 と Trait2 を実装している T 型のみがメソッドを使用することができる（トレイト境界によりメソッドの呼出し可否をコントロールする）
- 戻り値としてのトレイト
  - 文法：`fn` 関数名() -> `impl` トレイト名 { 実装 }
  - 利点：クロージャとイテレータの作り出す型は、コンパイラだけが知っているものであったり、指定するには長すぎるものであったりします。 impl Trait 構文を使えば、非常に長い型を書くことなく、ある関数は Iterator トレイトを実装するある型を返すのだ、と簡潔に指定することができます。
  - 制約：impl Trait は一種類の型を返す場合にのみ使える
- ブランケット実装（_blanket implementation_）：トレイト境界を満たすあらゆる型にトレイトを実装すること
  - 例：
    - Display トレイトを実装するあらゆる型に ToString トレイトを実装
      - `impl` `<T:` Display`>` ToString `for` `T` { --snip-- }
      - ⇒ Display トレイトを実装する任意の型が、 ToString トレイトで定義された to_string メソッドを呼び出せる
  - ブランケット実装はトレイトのドキュメンテーションの _Implementors_ 節に出現する
- 関連型（_associated types_）
  - 意義：トレイトと型のプレースホルダーを結び付ける
  - 類似：トレイトのメソッド定義がシグニチャでプレースホルダーの型を使用できる
  - 関連型があるトレイトの一例
    - Iterator トレイト
      - Iterator トレイトの関連型
        - `Item` と命名されている
        - Iterator トレイトを実装した型が反復する値の型
        - プレースホルダー型
        - Iterator トレイトを実装するものは、Item の具体的な型を指定し、next メソッドは、 その具体的な型の値を含む Option を返す
  - ジェネリックとの差異
    - ジェネリックの場合：トレイトにジェネリックな引数があると、 毎回ジェネリックな型引数の具体的な型を変更してある型に対して複数回実装できる
      - 例：Iterator がジェネリックを使用していたら、ある構造体（Counter）について、`Iterator<String> for Counter`、`Iterator<u32> for Counter` といったように Counter の Iterator の実装が複数できる
      - ⇒ Counter に対して next メソッドを使用する際に、どの Iterator の実装を使用したいか型注釈をつけなければならないでしょう。
    - 関連型の場合：同じ型に対してトレイトを複数回実装できない
      - `impl Iterator for Counter`は１つしか存在しえず、 next を呼び出す度に、 u32 値を型注釈する必要がなくなる
- デフォルトのジェネリック型引数
  - 記法：`<PlaceholderType=ConcreteType>`
  - 効果：既定の型（`ConcreteType`）が動くのなら、トレイトを実装する側は具体的な型を指定する必要がなくなる
  - ユースケース：
    - 既存のコードを破壊せずに型を拡張する
    - ほとんどのユーザは必要としない特定の場合でカスタマイズを可能にする
  - 使用例：
    - [Add トレイト](https://doc.rust-lang.org/std/ops/trait.Add.html)（`trait Add<Rhs = Self>`）
- フルパス記法（_Fully Qualified Syntax_）
  - 必要性：同じ名前のメソッドを呼ぶ際、コンパイラにどれを使用したいのか教える必要がある
    - ∵ Rust において、別のトレイトのメソッドと同じ名前のメソッドがトレイトにあったり、両方のトレイトを 1 つの型に実装することを妨げるものは何もない
  - 注意：同じ名前を使用する実装が複数あり、どの実装を呼び出したいかコンパイラが特定するのに助けが必要な場合だけにしようする（冗長であるため）
  - 記法： `<Type as Trait>::function(receiver_if_method, next_arg, ...);`
    - 関連関数では、receiver がないでしょう
- スーパートレイト
- 時として、あるトレイトに別のトレイトの機能を使用させる必要がある場合

### トレイトオブジェクト

- 意義：指定したトレイトを実装するある型のインスタンス
  - どこでトレイトオブジェクトを使用しようと、 Rust の型システムは、コンパイル時にその文脈で使用されているあらゆる値がそのトレイトオブジェクトのトレイトを実装していることを保証する
- 目的：共通の振る舞いに対して抽象化を行うこと
- memo: TypeScript の interface でも同じことができると思う。TypeScript の方が型が緩いから トレイトもトレイトオブジェクトも TypeScript では interface という概念になると思う。
- 記法：
  - `&`Trait
  - `Box<Trait>`
- 利用可能場面：
  - ジェネリックまたは具体的な型があるコード
- 類似：他の言語のオブジェクト
  - 類似点：データと振る舞いをごちゃ混ぜにする点
  - 相違点：トレイトオブジェクトにはデータを追加できない点
- ジェネリックな型引数との違い
  - ジェネリックな型引数：一度に 1 つの具体型にしか置き換えられない
  - トレイトオブジェクト：実行時にトレイトオブジェクトに対して複数の具体型で埋めることができる
- 制約：
  - オブジェクト安全なトレイトである必要がある
    - オブジェクト安全：トレイト内で定義されているメソッド全てが以下の特性を持つこと
      - 戻り値の型が Self でない
        - Self キーワード：トレイトやメソッドを実装しようとしている型の別名
        - ∵ トレイトオブジェクトを使用したら、コンパイラにはそのトレイトを実装している具体的な型を知りようがない。
          - ⇒ Self を使ってしまったら、コンパイル時に型をチェックできなくなる。
      - ジェネリックな型引数がない
- トレイトの実装：
  - 制約：
    - コヒーレンス(coherence)、孤児のルール（オーファンルール・_orphan rule_）：
      - トレイトか対象の型が自分のクレートに固有(local)である時のみ、 型に対してトレイトを実装できる
      - iow: 外部のトレイトを外部の型に対して実装することはできない
      - 効果：他の人のコードが自分のコードを壊したり、 その逆が起きないことを保証する
        - この規則がなければ、2 つのクレートが同じ型に対して同じトレイトを実装できてしまい、 コンパイラはどちらの実装を使うべきかわからなくなってしまう
      - 制約されない場合の例
        - Display のような標準ライブラリのトレイトを独自クレート固有の型に実装すること
        - 独自のクレート固有のトレイトを、標準の`Vec<T>`に対して実装すること
      - 制約される場合の例
        - 独自クレート内で`Vec<T>`に対して`Display`トレイトを実装すること
          - ∵ `Display`と`Vec<T>`は標準ライブラリで定義され、独自クレートに固有ではない
      - 制約を回避するパターン
        - ニュータイプパターン
          - トレイトを実装したい型のラッパとしてタプル構造体を利用する
            - ⇒ ラッパの型はクレートにローカルなので、トレイトをラッパに実装できる

### イテレータ

- 効果：一連の要素に順番に何らかの作業を行う
- 責任：各要素を繰り返し、シーケンスが終わったことを決定する
- 性質：怠惰（_lazy_）
- トレイト：[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html)
  - next の性質：イテレータ生成メソッド`into_iter`,`iter_mut` によって異なる
  - 消費アダプタ（_consuming adaptors_）：
    - 呼び出すとシーケンスを消費するメソッド
      - iow: next を呼び出すメソッド
  - 例
    - `sum`メソッド
- Rust のゼロコスト抽象化が機能する

### スマートポインタ用のトレイト

- `Deref` トレイト
  - 実装対象：`deref`メソッド
  - 機能：スマートポインタ構造体のインスタンスは、 参照のように振る舞うことができる
    - ⇒ ポインタのように振る舞う
    - ⇒ 参照あるいはスマートポインタのどちらとも動作するコードを書くことができる
  - 参照外し演算子の`*`の振る舞いをカスタマイズできる
  - 参照外し型強制（_deref coercion_）
    - Deref トレイトが関係する型に定義されていると、コンパイラは、型を分析し、必要なだけ Deref::deref を使用して、 参照を得て、引数の型と一致させる
      - 以下の 3 つの場合に型やトレイト実装を見つけた時にコンパイラは、参照外し型強制を行います:
        - T`: Deref<Target=U>`の時、`&T`から`&U`
        - T: `DerefMut<Target=U>`の時、`&mut T`から`&mut U`
        - T`: Deref<Target=U>`の時、`&mut T`から`&U`
          - memo: `&T`から`&mut U`がないのは当然か
- `Drop` トレイト
  - 実装対象：`drop`メソッド
    - Rust の drop 関数は、 1 種の特定のデストラクタ
  - 機能：スマートポインタのインスタンスがスコープを外れた時に走るコードを指定することができる
    - ⇒ 特定の型のインスタンスを使い終わったプログラムの箇所全部にクリーンアップコードを配置するのに配慮する必要はない
  - std::mem::drop
    - 早期に値をドロップさせることができる
    - ※ 直接`drop`関数を呼ぶことはできない

### クロージャ

- 意義：変数に保存したり、引数として他の関数に渡すことのできる匿名関数
- 関数との相違点：
  - 呼び出されたスコープの値をキャプチャすることができる
- 記法：
  - 例：
    - `fn add_one_v1 (x: u32) -> u32 { x + 1 }` 関数
    - `let add_one_v2 = |x: u32| -> u32 { x + 1 };` クロージャ
    - `let add_one_v3 = |x| { x + 1 };` クロージャ
      - 型は最初の呼出しの時点で推論される
    - `let add_one_v4 = |x| x + 1 ;` クロージャ
      - `{}`はクロージャの本体がただ 1 つの式からなる場合、省略可能
- 実装トレイト：全てのクロージャは、[`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html)、`FnMut`、`FnOnce`のいずれかのトレイトを実装している
- 環境のキャプチャ
  - 意義：自分が定義されたスコープの変数へのアクセス
  - 関数では不可
  - 内部動作：
    - メモリを使用してクロージャ本体で使用できるようにその値を保存する
      - ⇒ オーバーヘッドになる
        - ⇒ 関数を定義して使えば、このオーバーヘッドを招くことは絶対にありません
  - キャプチャ方法（3 つ）
    - FnOnce
      - 変数の所有権を奪う
        - ⇒ ２回以上呼べない
          - ⇒ 名前に`Once`が付いた
    - FnMut
      - 値を可変で借用する
    - Fn
      - 値を不変で借用する
    - 使い分け
      - コンパイラは、クロージャが環境を使用する方法に基づいて推論する
      - 全てのクロージャは`FnOnce`を実装している
      - キャプチャした変数をムーブしないクロージャは、 `FnMut`も実装
      - キャプチャした変数に可変でアクセスする必要のないクロージャは、`Fn`も実装
      - memo: つまり、クロージャーは「３つ全てを実装している」か「`FnOnce`と`FnMut`を実装している」か「`FnOnce`のみを実装している」のどれかということか
- アドバイス：Fn トレイトのどれかを指定するほとんどの場合、Fn から始めると良い
  - ∵ コンパイラは FnMut や FnOnce が必要な場合教えてくれる
- `move` キーワード
  - 効果：クロージャの引数リストの前に move キーワードを使用すると、クロージャに環境で使用している値の所有権を強制的に奪わせることができる
    - あるスレッドから別のスレッドに値の所有権を移すために新しいスレッドを生成する際に特に有用

## ライフタイム

- 概要：
  - その参照が有効になるスコープ
  - コンパイラに「参照がお互いにどう関係しているか」の情報を与える、一種の（ライフタイム版の）ジェネリクス
    - ⇒ `<'a, T>`というように型引数`T`と同列に書く
- 他のプログラミング言語との比較：ライフタイムの概念は、他のプログラミング言語の道具とはどこか異なり、間違いなく、 Rust で一番際立った機能になっている
- 多くの場合、暗黙的に推論される
  - 型が推論されることと同じ
- 参照のライフタイムがいくつか異なる方法で関係することがある場合には注釈が必要
  - 類似：複数の型の可能性があるときには、型注釈が必要
- ライフタイム注釈
  - 注釈は、複数の参照のジェネリックなライフタイム引数が、 お互いにどう関係するかをコンパイラに指示することを意図している
  - 参照の生存期間も変えることは決してない
  - 関数へのライフタイム注釈が必要になる場面
    - 関数に関数外からの参照（引数で参照を受け取る）や関数外への参照（戻り値で参照を返す）がある場合
      - ∵ この場合、コンパイラが引数や戻り値のライフタイムを自力で解決することはほとんど不可能
        - ⇒ ライフタイム注釈は、関数の引数と戻り値のライフタイムを接続する
  - 記法：
    - ライフタイム引数の名前はアポストロフィー(')で始める
    - 通常すべて小文字で短く記載する（「'a」とすることが多い）
    - ライフタイム引数注釈は、参照の`&`の後に配置し、注釈と参照の型を区別するために空白を 1 つ使用する
    - 例：
      - `&i32` (ただの)参照
      - `&'a i32` 明示的なライフタイム付きの参照
      - `&'a mut i32` 明示的なライフタイム付きの可変参照
      - `fn longest<'a>(x: &'a str, y: &'a str) -> &'a str { --snip-- }`
        - このシグニチャで表現したい制約は、引数の全ての参照と戻り値が同じライフタイムを持つこと
        - このシグニチャを満たすようなスコープを`'a`に代入できるということをコンパイラに伝える
        - `'a`は`x`と`y`のうち、短いライフタイムを持つ方のライフタイムとなる
        - memo: 正直この場合は、コンパイラがライフタイムを推論してくれても良いのでは？と思ってしまう。「全ての引数を戻り値に使っている場合、戻り値のライフタイムは最短のものを使う」と推論してもよいのでは？もっと複雑になった場合の例が欲しい。
          - memo: と思ったら「将来的に、さらに少数のライフタイム注釈しか必要にならない可能性もあります。」と書いてあった。コンパイラの参照解析に落とし込まれたパターンは、ライフタイム省略規則（_lifetime elision rules_）というらしい。
- 入力ライフタイム：関数やメソッドの引数のライフタイム
- 出力ライフタイム：戻り値のライフタイム
- 明示的な注釈がない場合のライフタイム省略規則（_lifetime elision rules_）：
  - ルール：参照を受け取る引数はそれぞれ独立した個別のライフタイムをもつものと見做される
  - ルール：入力ライフタイム引数がたった一つの場合、そのライフタイムと出力ライフタイムは同一と見做される
  - ルール：メソッドの場合（引数の一つが`&self`や`&mut self`だった場合）、出力ライフタイムは`self`のライフタイムと見做す。
  - memo: _all output lifetime parameters_ が複数形になっているのは `return` が複数ある場合のことを踏まえたからか。_parameters_ と書いているのは、ジェネリックを引数に見立てているからか。
  - 上記の全てのルールを適用してもライフタイムが決定されない場合、ライフタイム注釈が必要になる。
  - ライフタイム省略規則はライフタイム注釈を持つ構造体のメソッドにも適用される
- 静的ライフタイム
  - プログラム全体の期間
  - 文字列リテラルは全て'static ライフタイムになる
  - 注意：エラーメッセージで'static ライフタイムを使用する提言を目撃しても、安易に'static ライフタイムを使わない
  - その他例：
    - いつ実行し終わるか分からないスレッドに処理させる関数のライフタイム

## テスト

- 属性：Rust コードの部品に関するメタデータ
  - 例：derive 属性
  - `test`
    - 関数をテスト関数として扱う
  - `should_panic`
    - 関数内のコードがパニックしたら、テストを通過させ、パニックしなかったら失敗させる
    - should_panic のテストの正確を期すために、should_panic 属性に`expected`引数を追加することもできます。
  - `ignore`：テストをスキップする
  - `cfg`：この属性に続くアイテムが、ある特定の設定オプションを与えられたら、そのアイテムを含むように、コンパイラに指示
    - configuration の意味
    - 例：`#[cfg(test)]`：`cargo test` でテストを実行した場合のみ、 Cargo がテストコードをコンパイルする。
      - ⇒ 本番コードにテストコー含まれなくなる
      - 注意：`#[cfg(test)]`注釈を付与したモジュールに含まれるヘルパー関数もコンパイルされる（#[test]で注釈された関数だけコンパイルされるのではない）
  - [導出可能なトレイト](https://doc.rust-jp.rs/book-ja/appendix-03-derivable-traits.html)
- テスト関数：test 属性で注釈された関数／fn の前に#[test]を付け加えた関数
  - cargo test コマンドでテストを実行したら、コンパイラは test 属性で注釈された関数を走らせるテスト用バイナリをビルドし、 各テスト関数が通過したか失敗したかを報告します。
  - `panic!`マクロの呼出しで FAIL する
  - `Result<T, E>.Err`の返却で FAIL する
    - 注意：`Result<T, E>`を使うテストに#[should_panic]注釈を使うことはできない
- マクロ
  - `assert_eq!`と `assert_ne!`
    - 比較対象の値は `PartialEq` と `Debug` トレイトを実装していなければなりません。
      - ∵ PartialEq：内部的に`==`、`!=`演算子を利用
      - ∵ Debug：アサーションが失敗すると、これらのマクロは引数をデバッグフォーマットを使用してプリントする
    - 例：`assert_eq!(2 + 2, 4);`
    - `assert_ne!`： `assert_eq!`の逆
    - リンク：[assert_eq](https://doc.rust-lang.org/std/macro.assert_eq.html)
  - `assert!`
    - true なら OK
    - 例：`assert!(larger.can_hold(&smaller));`
- cargo test
  - `cargo test some_test`： some_test という文字列を含む関数のみをテストする
  - デフォルト：
    - 複数スレッドを使用して並行処理する
    - FAIL した関数の標準出力のみ表示される
  - コマンドラインオプション
    - cargo test にかかるものと、出来上がったテストバイナリにかかるものとがある
      - cargo test にかかるオプション：
        - `--`という区分記号の後
        - 例：cargo test -- --help
        - `--test-threads`フラグ
          - `cargo test -- --test-threads=1`
            - テストスレッドの数を 1 にセットし、並行性を使用しないようにプログラムに指示
              - 書くプログラムが一つのファイルを扱う場合など、並列処理だと困る場合に使う
        - `cargo test -- --nocapture`
          - 出力キャプチャ機能（ok なケースの標準出力の抑制）を無効化
          - デフォルトではテストは並列で実行されるので標準出力はあべこべになる
        - `cargo test -- --ignored`
          - `ignored`属性のテスト関数のみを実行する
      - 出来上がったテストバイナリにかかるオプション
        - `--`という区分記号の前
        - 例：cargo test --help
        - `cargo test --test` ファイル名：特定の結合テストファイルにあるテストを全て走らせる
- 単体テスト
  - 目的：残りのコードから切り離して各単位のコードをテストし、 コードが想定通り、動いたり動いていなかったりする箇所を迅速に特定すること
  - 配置場所：テスト対象となるコードと共に、src ディレクトリの各ファイルに置く
    - 慣習：各ファイルに tests という名前のモジュールを作り、テスト関数を含ませ、 そのモジュールを `cfg(test)`で注釈する
  - 非公開関数をテストすることもできる（同じファイル内なら非公開関数を実行できるから）
- #[cfg(test)]という注釈：コンパイラに cargo build を走らせた時ではなく、cargo test を走らせた時にだけ、 テストコードをコンパイルし走らせるよう指示する
  - ⇒ ライブラリをビルドしたいだけの時にはコンパイルタイムを節約
  - ⇒ テストが含まれないので、コンパイル後の成果物のサイズを節約
  - 単体テストを慣習通りにテスト対象と同じファイルにテストを書く場合に`#[cfg(test)]`が必要となる
    - ⇒ 結合テストは別のディレクトリに存在することになるので、`#[cfg(test)]`注釈は必要ない
- 結合テスト
  - 目的：ライブラリのいろんな部分が共同で正常に動作しているかをテストすること
    - ∵ 単体では正常に動くコードも、結合した状態だと問題を孕む可能性もある
  - ライブラリの公開 API を使用して外部コードが使用するのと同じ方法でコードをテストする
  - tests ディレクトリ
    - 結合テストの作成に必要
    - 場所：プロジェクトディレクトリのトップ階層（src の隣）
    - Cargo は tests ディレクトリ内のそれぞれのテストファイルを個別のクレートとしてコンパイルする
      - ⇒ テストファイルは、`extern crate`で、各々ライブラリをインポートする必要がある
      - 但し：テストディレクトリのサブディレクトリにあるファイルは、個別のクレートとしてコンパイルされたり、テスト出力にセクションが含まれたりすることはない。
    - Cargo は tests ディレクトリを特別に扱い、cargo test を走らせた時にのみこのディレクトリのファイルをコンパイルする
      - ⇒ `#[cfg(test)]`注釈は不要

## OOP と Rust

- OOP の概念とその概念が Rust に存在するかどうか
  - オブジェクト：有り（「オブジェクト」を、データとそのデータを処理するプロシージャをまとめたものと定義する場合）
    - Rust の構造体と enum にはデータがある
    - impl ブロックが構造体と enum にメソッドを提供する
    - ※ Rust では、構造体と enum を他の言語のオブジェクトと区別するために「オブジェクト」と呼ぶことを避けている
  - カプセル化：有り
    - Rust では、`pub`キーワードでプライバシーの設定が可能
  - 承継：無し
    - 親構造体のフィールドとメソッドの実装を受け継ぐ構造体を定義する方法は無い
    - 継承のメリットについて
      - コードの再利用：ある型に特定の振る舞いを実装し、 継承により、その実装を他の型にも再利用する
        - Rust では：デフォルトのトレイトメソッド実装を代わりに使用して、 Rust コードを共有できる
      - 多相性（_polymorphism_ / 親の型と同じ箇所で子供の型を使用可能 ⇒ 複数のオブジェクトが特定の特徴を共有しているなら、 実行時にお互いに代用できることを意味する）
        - Rust では：代わりにジェネリクスを使用して様々な可能性のある型を抽象化し、トレイト境界を使用してそれらの型が提供するものに制約を課す（パラメータ境界多相性 _bounded parametric polymorphism_）
    - 継承の問題点
      - 過剰なコード共有の危険性：サブクラスは、 必ずしも親クラスの特徴を全て共有するべきではないのに、継承ではそうなってしまう
      - 一つのクラスからしか承継できない言語もあるが柔軟性に欠ける
  - 注意：
    - オブジェクト指向のパターンは、オブジェクト指向言語にはない所有権などの機能のある Rust においては、必ずしも最善の解決策ではない可能性がある
- ステートパターン
  - 要点：値がステートオブジェクトで表されるなんらかの内部状態を持ち、 その内部の状態に基づいて値の振る舞いが変化する
  - 利点：プログラムの業務用件が変わる時、状態を保持する値のコードや、 値を使用するコードを変更する必要はない
  - ステートオブジェクト
    - 状態変化時、振る舞い・制御に責任を持つ
  - ステートオブジェクトを保持する値
    - 状態ごとの異なる振る舞いや、いつ状態が移行するかについては何も知らない

## マルチスレッド

- スレッド：プログラム内で、独立して実行される機能
- マルチスレッド：
  - リスク
    - 競合状態：スレッドがデータやリソースに矛盾した順番でアクセスする
    - デッドロック：2 つのスレッドがお互いにもう一方が持っているリソースを使用し終わるのを待ってしまう状態
    - 再現や修正が困難なバグ：特定の状況でのみ起きるバグ
  - 「注意深い思考」と「シングルスレッドで走るプログラムとは異なるコード構造」が必要
- グリーンスレッド：プログラミング言語が提供するスレッド
- M:N モデル：M 個のグリーンスレッドに対して、 N 個の OS スレッドがある（M と N は必ずしも同じ数字でない）
  - グリーンスレッドを使用する言語は、それを異なる数の OS スレッドの文脈で実行する
  - 大きな言語ランタイムが必要（スレッドを管理するコード）
- 1:1 モデル：
  - 意義：言語が OS の API を呼び出してスレッドを生成するこのモデル
  - 例：Rust
    - （Rust には、M:N スレッドの実装をしたクレートもある）
- （言語）ランタイム
  - 注意：「ランタイム」という用語は文脈によって意味が異なるので注意
  - 意義：コンパイルして出来上がるバイナリに対して必ず含まれることになる、言語が提供するバイナリコード
  - 小さいランタイム：
    - 欠点：機能が少ない
    - 利点：
      - バイナリサイズが小さくなる
      - 他の言語と組み合わせて使えることが多くなる？
  - Rust：
    - ランタイムはほとんどゼロ
- メッセージ受け渡し（メッセージ送信並行性）
  - 安全な並行性を保証するアプローチの一つ
  - チャンネル（channel）：
    - メッセージ送信並行性を達成するため Rust が標準ライブラリで提供するプログラミング概念
    - 比喩： 水の流れ（小川とか川）
      - アヒルのおもちゃやボートみたいなものを流れに置いたら、 水路の終端まで下流に流れていきます。
    - 2 分割できる
      - 転送機
        - 比喩：アヒルのおもちゃを川に置く上流側
      - 受信機
        - 比喩：アヒルのおもちゃが行き着く下流側
    - チャンネルが閉じられた（_closed_）
      - 意義：転送機と受信機のどちらかがドロップされた
- 状態共有並行性（_Shared-State Concurrency_）
  - ミューテックス（_Mutex_）
    - 意義： "mutual exclusion"（相互排他）の省略形で、どんな時も 1 つのスレッドにしかなんらかのデータへのアクセスを許可しないということ
    - 方法：ロックシステム経由で保持しているデータを死守（guarding）する
      - ロックシステムとは：現在誰がデータへの排他的アクセスを行なっているかを追跡するミューテックスの一部をなすデータ構造です。
    - 規則：
      - データを使用する前にロックの獲得を試みなければならない
      - ミューテックスが死守しているデータの使用が終わったら、他のスレッドがロックを獲得できるように、データをアンロックしなければならない
        - ⇒ ミューテックスの管理は難しい
          - ⇒ メッセージ受け渡し（チャンネル）が人気になった
          - Rust の型システムと所有権規則はこの管理を簡単にする
    - 比喩：マイクが 1 つしかない会議のパネルディスカッション
      - パネリストが発言できる前に、マイクを使用したいと申し出たり、通知しなければなりません
      - マイクを受け取ったら、 話したいだけ話し、それから次に発言を申し出たパネリストにマイクを手渡します
      - パネリストが発言し終わった時に、 マイクを手渡すのを忘れていたら、誰も他の人は発言できません
        - 共有されているマイクの管理がうまくいかなければ、 パネルは予定通りに機能しない
- 拡張可能な並行性
  - Rust には 並行処理（_concurrency_） 機能がほとんどない
  - std::marker
    - `Send` マーカートレイト
      - Send を実装した型の所有権はスレッド間で転送できる
      - Rust のほとんどの型は Send
        - 例外：`Rc<T>`
        - Send 型からのみ構成される型は Send になる
        - 生ポインタを除くほとんどの primitive 型も Send
    - `Sync` マーカートレイト
      - Sync を実装した型は、複数のスレッドから参照されても安全である
      - Sync であるもの
        - Sync 型からのみ構成される型は Sync になる
        - primitive 型
        - `Mutex<T>`
      - Sync でないもの
        - `Rc<T>`、`Cell<T>`系
    - `Send`と`Sync`
      - 関係
        - `&T`（T への参照）が`Send`なら、型`T`は`Sync`
      - マーカートレイト：実装すべきメソッドがない

## Unsafe Rust

- 概要：
  - メモリ安全保証を強制しない第 2 の言語
- 目的：
  - 保守的な静的解析に対するエスケープハッチ
- 必要性：
  - ハードウェアは本質的に unsafe であり、unsafe を許可しないと出来ないことがある
- _unsafe superpowers_
  - 生ポインタを参照外しする
    - 生ポインタ
      - `*const T`
      - `*mut T`
      - 注意：
        - アスタリスクは、参照外し演算子ではなく、型名の一部
      - 不変（生ポインタの文脈）：
        - 意味：参照外し後に直接ポインタに代入できないこと
      - 性質（参照やスマートポインタと異なる点）
        - 同じ場所への不変と可変なポインタや複数の可変なポインタが存在することで借用規則を無視できる
        - 有効なメモリを指しているとは保証されない
        - null の可能性がある
        - 自動的な片付けは実装されていない
    - ユースケース：
      - 一般論：
        - プログラマには問題ないわかるのに、コンパイラにはわからないコード
      - C コードとのインターフェイス
      - 借用チェッカーには理解できない安全な抽象を構成する
  - unsafe な関数やメソッドを呼ぶ
    - `extern`ブロック内で宣言された関数
      - `extern`キーワード
        - FFI(Foreign Function Interface: 外部関数インターフェイス)の生成と使用を容易にする
          - FFI：あるプログラミング言語に関数を定義させ、異なる(外部の)プログラミング言語にそれらの関数を呼び出すことを可能にする方法
        - 記法：`extern` ABI {}
          - ブロック内で他の言語から呼び出した関数の名前とシグニチャを列挙します
          - ABI：
            - 構文上の意味：外部関数がどの ABI(application binary interface: アプリケーション・バイナリ・インターフェイス)を使用するか
            - ABI の意味：関数の呼び出し方法をアセンブリレベルで定義したもの
            - 例：`"C"`
              - `"C"`ABI は最も一般的で C プログラミング言語の ABI に従っています
        - 他の言語から Rust の関数を呼び出す文法も存在する
          - 割愛
      - unsafe である理由：他の言語では、Rust の規則や保証が強制されず、コンパイラもチェックできないので、 安全性を保証する責任はプログラマに降りかかる
  - 可変な静的変数にアクセス（read）したり変更（write）する
    - 理由：グローバルにアクセス可能な可変なデータがあると、データ競合がないことを保証するのは難しくなるため
    - 並行性テクニックとスレッド安全なスマートポインタを使用するのが望ましい
  - unsafe なトレイトを実装する
    - unsafe なトレイト
      - 条件：少なくとも、1 つのメソッドにコンパイラが確かめられないなんらかの不変条件がある
- unsafe キーワード
  - 効果：
    - 4 つの unsafe な処理を unsafe で注釈されたブロックに入れる必要があることで、 メモリ安全性に関するどんなエラーも unsafe ブロック内にあるに違いないと知ります。
      - iow: 明示的に unsafe 注釈をすることで問題が起きたら、 その原因を追求するのが容易になる
  - 助言：
    - unsafe ブロックは小さくする
    - unsafe なコードをできるだけ分離するために、unsafe なコードを安全な抽象の中に閉じ込め、安全な API を提供するのが最善
      - 例
        - 標準ライブラリの一部は、 検査された unsafe コードの安全な抽象として実装されています

## マクロ

- 用語：ある機能の集合のこと
- 役割：メタプログラミング（他のコードを記述するコードを書く）
- 必要性・目的：書いて管理しなければならないコードの量を減らす
- 機能：展開されコードを生成する
- 種類：
  - 宣言的 (declarative) マクロ
    - 別称：例によるマクロ、macro_rules!マクロ、（単に）マクロ
    - パターンマッチングを行い、マッチしたコードを他のコードで置き換える
  - 手続き的 (procedural) マクロ
    - コードを入力として受け取り、そのコードに対して作用し、出力としてコードを生成する
      - 手続き的マクロを定義する関数は `TokenStream` を入力として受け取り、`TokenStream` を出力として生成する
        - `TokenStream`型
          - Rust に内蔵されている`proc_macro`クレートで定義
          - トークンの列を表す
          - マクロが作用するソースコードは、入力の TokenStream へと変換される
      - `proc_macro` クレート
        - コンパイラの API
        - 私達のコードから Rust のコードを読んだり操作したりすることを可能にする
      - `syn` クレート
        - 文字列から Rust コードを構文解析し、 処理を行えるデータ構造にする
      - `quote` クレート
        - syn データ構造を取り、Rust コードに変換し直す
    - 種類
      - カスタムの#[derive]マクロ（Custom #[derive] macro）：構造体と enum に derive 属性を使ったときにコードを追加する
        - 構造体と enum にしか使えない
      - 属性風のマクロ（Attribute-like macros）：任意の要素に使えるカスタムの属性を定義する
        - 幅広いアイテムに対して使用可能
      - 関数風のマクロ（Function-like macros）：関数のように見えるが、引数として指定されたトークンに対して作用する
        - 任意の数の引数を取ることができる
- マクロと関数の違い：
  - シグニチャ：
    - 関数：引数の数と型の宣言が必須
    - マクロ：可変長の引数を取れる
  - 機能するタイミング：
    - マクロ：コンパイラがコードの意味を解釈する前に展開される
      - ⇒ 与えられた型にトレイトを実装できる
    - 関数：実行時に呼ばれる
  - 扱いやすさ：一般的に、 関数定義よりも、読みにくく、わかりにくく、管理しづらい
  - 定義・スコープへの導入の位置：
    - マクロ：ファイル内に呼び出す前
    - 関数：いつでもどこでも
- `#[macro_export]`注釈
  - マクロを定義しているクレートがスコープに持ち込まれたなら、無条件で対象のマクロが利用可能になる
- （マクロの）パターン
  - （match 式のパターンとは異なる）
  - Rust コードの構造に対してマッチされる
  - リンク
    - [参考文献](https://doc.rust-lang.org/reference/macros.html)
    - [The Little Book of Rust Macros](https://danielkeep.github.io/tlborm/book/index.html)

## リンク

- [キーワード一覧](https://doc.rust-lang.org/stable/book/appendix-01-keywords.html)
- [Rust Documentation（公式ドキュメント）](https://doc.rust-lang.org/stable/#the-rust-programming-language)
- [Docker Official Images](https://hub.docker.com/_/rust)
  - とりあえず docker で試す：`docker container run -it rust`
    - ディストリビューション名確認：`cat /etc/issue`
    - [version 確認](https://eng-entrance.com/linux-os-version)：`cat /etc/debian_version`

## 一時保存メモ

- 10.2.
  - クロージャとイテレータの作り出す型は、コンパイラだけが知っているものであったり、指定するには長すぎるものであったりします。
- 15.5
  - コンパイル時に借用規則を精査することの利点は、エラーが開発過程の早い段階で捕捉されることと、 あらかじめ全ての分析が終わるので、実行パフォーマンスへの影響がないことです。それらの理由により、 多くの場合でコンパイル時に借用規則を精査することが最善の選択肢であり、これが Rust の既定になっているのです。
  - 借用規則を実行時に精査する利点は、コンパイル時の精査では許容されない特定のメモリ安全な筋書きが許容されることです。 Rust コンパイラのような静的解析は、本質的に保守的です。コードの特性には、コードを解析するだけでは検知できないものもあります: 最も有名な例は停止性問題であり、この本の範疇を超えていますが、調べると面白い話題です。
- 20.2
  - スレッドプール
    - 意義：待機し、タスクを処理する準備のできた一塊りの大量に生成されたスレッド
      - プログラムが新しいタスクを受け取ったら、プールのスレッドのどれかをタスクにあてがい、 そのスレッドがそのタスクを処理します。
    - 効果：並行で接続を処理でき、サーバのスループットを向上させます。
    - プール内のスレッド数
      - 小さい数字に制限する（無制限にスレッドを大量生産するのではなく、プールに固定された数のスレッドを待機させます）
        - ∵ DoS(Denial of Service; サービスの拒否)攻撃から保護します; リクエストが来た度に新しいスレッドをプログラムに生成させたら、 1000 万リクエストをサーバに行う誰かが、サーバのリソースを使い尽くし、リクエストの処理を停止に追い込むことで、 大混乱を招くことができてしまうでしょう。
- WSL2

```bash
docker container run -v "$(pwd)":/tmp -w /tmp rust:latest cargo new spawn_sample
```

## Rust を学んでみた感想

- 所有権システムやライフタイムは新しいが、違和感のあるものではない
  - ルール一つひとつに納得の行く理由がある
- エラー文が分かりやすい
  - だいたいコンパイルエラーはエラー文を見れば解決出来そう
- 「Rust のエラー処理機能は、プログラマがより頑健なコードを書く手助けをするように設計されています。」に納得した
  - 回復可能なエラーと回復不能なエラーが言語仕様レベルで切り分けられているのは素晴らしい
    - 「多くの言語では、 回復可能なエラーと回復不能なエラーの 2 種類のエラーを区別することはなく、例外などの機構を使用して同様に扱う。」
  - 「undefined や null になり得る値」は本当に身近な存在であり、そういった身近で良く登場する存在を上手いこと扱ってくれる仕組み（Option や Result、及びそれらに付随するメソッド）があった方が楽
  - `?`演算子によるエラー制御が強力
    - 最初素晴らしいと思うあまり笑ってしまった
    - 命令的な記述を可能にするという点で、JavaScript の await に似ている
- 後ろの文脈からでも判断してくれるのが凄い
  - 例：8-26 参照
- 不満
  - VSCode でメソッド一覧がでないときがある？
  - collect メソッドの戻り値に型注釈が必要なのが違和感
  - 構造体のフィールドから所有権を得るとき Option.take を使わないといけない
    - 「所有権システム」 + 「null の排除」の帰結か
  - ファイル間でのアイテムの共有が面倒
    - ライブラリクレートを作成し、[dependencies]欄にそのライブラリクレートを登録しないといけない？
    - ただし、依存関係への意識が強くなり、初心者でも依存の循環を起こしにくいと感じる
